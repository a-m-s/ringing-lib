dnl -*- M4 -*- configure.in - Autoconf script for the Ringing Class Library

dnl Process this file with autoconf to produce a configure script.

dnl Copyright (C) 2001, 2002 Martin Bright <M.Bright@dpmms.cam.ac.uk>
dnl and Richard Smith <richard@ex-parrot.com>

dnl This program is free software; you can redistribute it and/or modify
dnl it under the terms of the GNU General Public License as published by
dnl the Free Software Foundation; either version 2 of the License, or
dnl (at your option) any later version.

dnl This program is distributed in the hope that it will be useful,
dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
dnl GNU General Public License for more details.

dnl You should have received a copy of the GNU General Public License
dnl along with this program; if not, write to the Free Software
dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

dnl $Id$


AC_INIT(ringing/method.cpp)
AC_CONFIG_AUX_DIR(config)
AM_INIT_AUTOMAKE(ringing-lib, 0.2.6)
AM_CONFIG_HEADER(config.h)
AC_SUBST(ac_aux_dir)

can_build=yes

dnl Checks for programs.
AC_PROG_CXX
AC_PROG_RANLIB

dnl Checks for libraries.

dnl Checks for header files.
AC_HEADER_STDC


dnl --------------------------------------------------------------------------
dnl
dnl Now we check to see what the C++ headers are called
dnl
AC_LANG_CPLUSPLUS
AC_CHECK_HEADER([iostream], RINGING_OLD_INCLUDES=0
  iostream_name="<iostream>"
  list_name="<list>",
  [AC_CHECK_HEADER([iostream.h], RINGING_OLD_INCLUDES=1
    iostream_name="<iostream.h>"
    list_name="<list.h>",
    [AC_MSG_WARN([Can't find either <iostream> or <iostream.h>.  This means
that you don't appear to have the standard C++ libraries installed, which is 
necessary if you wish to compile or use the Ringing Class Library.])
    can_build=no])])
AC_SUBST(RINGING_OLD_INCLUDES)
AC_CHECK_HEADER([cstdio], RINGING_OLD_C_INCLUDES=0, RINGING_OLD_C_INCLUDES=1)
AC_SUBST(RINGING_OLD_C_INCLUDES)


dnl --------------------------------------------------------------------------
dnl
dnl Checks for typedefs, structures, and compiler characteristics.
dnl
AC_CXX_EXCEPTIONS
if test "$ac_cv_cxx_exceptions" = yes; then
  RINGING_USE_EXCEPTIONS=1;
else
  RINGING_USE_EXCEPTIONS=0;
fi
AC_SUBST(RINGING_USE_EXCEPTIONS)


dnl --------------------------------------------------------------------------
dnl
dnl Check if compile supports namespaces
dnl
dnl The use of the template class is important because it causes msvc-5
dnl to fail this test by trying to find A in namespace bar during the
dnl instantiation of the default argument of B::baz (or something equally 
dnl silly).  This is important because the STL frequently does this.
dnl
AC_CACHE_CHECK(
  [whether the compiler implements namespaces],
  [ac_cv_cxx_namespaces],
  [AC_TRY_COMPILE(
    [
      namespace bar
      {
        template <class T> struct B 
	{ 
	  void baz(const T & = T());
	};
      }
      namespace foo 
      {
        using namespace bar;
        class A {};
        void f() { B<A> b; b.baz(); }
      }
    ],
    [ foo::f(); ],
    ac_cv_cxx_namespaces=yes,
    ac_cv_cxx_namespaces=no
  )]
)
if test "$ac_cv_cxx_namespaces" = yes ; then
  RINGING_USE_NAMESPACES=1;
else
  RINGING_USE_NAMESPACES=0;
fi
AC_SUBST(RINGING_USE_NAMESPACES)


dnl --------------------------------------------------------------------------
dnl
dnl Check if platform supports template function specialisation
dnl
AC_CACHE_CHECK(
  [whether compiler supports template function specialisation],
  [ac_cv_cxx_template_function_specialisation],
  [AC_TRY_COMPILE(
    [
      template <class T> void foo(const T &) {}
      template <> void foo<int>(const int &) {}
    ],  
    [ foo((int)1); ],
    ac_cv_cxx_template_function_specialisation=yes,
    ac_cv_cxx_template_function_specialisation=no
  )]
)
if test "$ac_cv_cxx_template_function_specialisation" = yes ; then
  RINGING_USE_TEMPLATE_FUNCTION_SPECIALISATION=1
else
  RINGING_USE_TEMPLATE_FUNCTION_SPECIALISATION=0
fi
AC_SUBST(RINGING_USE_TEMPLATE_FUNCTION_SPECIALISATION)


dnl --------------------------------------------------------------------------
dnl
dnl Check to see whether instantiating a class instantiates its 
dnl members' definitions or just declarations
dnl
AC_CACHE_CHECK(
  [whether class instantiation prematurely instantiates members],
  [ac_cv_cxx_premature_member_instantiation],
  [AC_TRY_COMPILE(
    [
      class A {};
      template <class T> struct foo { 
        bool bar() const { return a < b; }
        T a, b;
      };
    ],
    [ foo<A> f; return 0; ],
    ac_cv_cxx_premature_member_instantiation=no,
    ac_cv_cxx_premature_member_instantiation=yes
  )]
)
if test "$ac_cv_cxx_premature_member_instantiation" = yes ; then
  RINGING_PREMATURE_MEMBER_INSTANTIATION=1
else
  RINGING_PREMATURE_MEMBER_INSTANTIATION=0
fi
AC_SUBST(RINGING_PREMATURE_MEMBER_INSTANTIATION)


dnl --------------------------------------------------------------------------
dnl
dnl Check to see whether a member class can be derived from a protected
dnl member class of the outer class.
dnl
AC_CACHE_CHECK(
  [whether member classes' base classes may be protected],
  [ac_cv_cxx_protected_member_bases],
  [AC_TRY_COMPILE(
    [
      class A {
      protected:
	class B {};
      };

      class C : public A {
        class D;
      };

      class C::D : public A::B {};
    ],
    [ return 0; ],
    ac_cv_cxx_protected_member_bases=yes,
    ac_cv_cxx_protected_member_bases=no
  )]
)
if test "$ac_cv_cxx_protected_member_bases" = yes ; then
  RINGING_PROTECTED_MEMBER_BASES=1
else
  RINGING_PROTECTED_MEMBER_BASES=0
fi
AC_SUBST(RINGING_PROTECTED_MEMBER_BASES)


dnl --------------------------------------------------------------------------
dnl
dnl Check to see whether the standard includes put their things in
dnl the std namespace
dnl
AC_CACHE_CHECK(whether standard includes use namespace std,
ac_cv_cxx_std,
[AC_TRY_COMPILE([#include] $iostream_name, [std::cout << 'x'; return 0;],
  ac_cv_cxx_std=yes, ac_cv_cxx_std=no)]
)
if test "$ac_cv_cxx_std" = yes; then
  RINGING_USE_STD=1;
else
  RINGING_USE_STD=0;
fi
AC_SUBST(RINGING_USE_STD)


dnl --------------------------------------------------------------------------
dnl
dnl Check to see whether the STL has a compliant std::iterator
dnl
AC_CACHE_CHECK(
  [whether the STL has a compilant std::iterator],
  [ac_cv_std_iterator],
  [AC_TRY_COMPILE(
    [
      #if ] $RINGING_OLD_INCLUDES [
      #  include <iterator.h>
      #else
      #  include <iterator>
      #endif

      #if ] $RINGING_USE_STD [ 
      using namespace std;
      #endif

      class iter
        : public iterator< input_iterator_tag, int, ptrdiff_t, int *, int & >
      {};
    ],
    [ return 0; ],
    ac_cv_cxx_std_iterator=yes,
    ac_cv_cxx_std_iterator=no
  )]
)
if test "$ac_cv_cxx_std_iterator" = yes ; then
  RINGING_HAVE_STD_ITERATOR=1
else
  RINGING_HAVE_STD_ITERATOR=0
fi
AC_SUBST(RINGING_HAVE_STD_ITERATOR)


dnl --------------------------------------------------------------------------
dnl
dnl Now check whether the STL seems to work
dnl
AC_CACHE_CHECK(whether the Standard Template Library works,
ac_cv_cxx_stl,
[AC_TRY_COMPILE([#include] $list_name [
#if] $RINGING_USE_STD [
using namespace std;
#endif],[list<int> l; l.push_back(3);
list<int>::iterator i = l.begin(); ++i; return 0;],
  ac_cv_cxx_stl=yes, ac_cv_cxx_stl=no)]
)
if test "$ac_cv_cxx_stl" = no; then
  AC_MSG_WARN([You do not appear to have a working version of the Standard
Template Library (STL), which is necessary for compiling and using the
Ringing Class Library.]);
  can_build=no;
fi

if test "$can_build" = no; then
  AC_MSG_WARN([Some problems were encountered which mean that you will not
be able to build the Ringing Class Library.  You will still be able to install
and read the documentation.  If you edit the file ringing/common-am.h to 
reflect what environment will be present when using the library, then you will
also be able to install the header files.]);
fi

AC_OUTPUT(Makefile ringing/Makefile doc/Makefile examples/Makefile 
  ringing/common-am.h)
