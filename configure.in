dnl Process this file with autoconf to produce a configure script.
dnl $Id$
AC_INIT(ringing/method.cpp)
AC_CONFIG_AUX_DIR(config)
AM_INIT_AUTOMAKE(ringing-lib, 0.2.6)
AM_CONFIG_HEADER(config.h)
AC_SUBST(ac_aux_dir)

can_build=yes

dnl Checks for programs.
AC_PROG_CXX
AC_PROG_RANLIB

dnl Checks for libraries.

dnl Checks for header files.
AC_HEADER_STDC
AC_REPLACE_FUNCS([argp_parse])

dnl Now we check to see what the C++ headers are called
AC_LANG_CPLUSPLUS
AC_CHECK_HEADER([iostream], RINGING_OLD_INCLUDES=0
  iostream_name="<iostream>"
  list_name="<list>",
  [AC_CHECK_HEADER([iostream.h], RINGING_OLD_INCLUDES=1
    iostream_name="<iostream.h>"
    list_name="<list.h>",
    [AC_MSG_WARN([Can't find either <iostream> or <iostream.h>.  This means
that you don't appear to have the standard C++ libraries installed, which is 
necessary if you wish to compile or use the Ringing Class Library.])
    can_build=no])])
AC_SUBST(RINGING_OLD_INCLUDES)
AC_CHECK_HEADER([cstdio], RINGING_OLD_C_INCLUDES=0, RINGING_OLD_C_INCLUDES=1)
AC_SUBST(RINGING_OLD_C_INCLUDES)

dnl Checks for typedefs, structures, and compiler characteristics.

AC_CXX_EXCEPTIONS
if test "$ac_cv_cxx_exceptions" = yes; then
  RINGING_USE_EXCEPTIONS=1;
else
  RINGING_USE_EXCEPTIONS=0;
fi
AC_SUBST(RINGING_USE_EXCEPTIONS)

dnl Check if compile supports namespaces
dnl
dnl The use of the template class is important because it causes msvc-5
dnl to fail this test by trying to find A in namespace bar during the
dnl instantiation of the default argument of B::baz (or something equally 
dnl silly).  This is important because the STL frequently does this.
AC_CACHE_CHECK(
  [whether the compiler implements namespaces],
  [ac_cv_cxx_namespaces],
  [AC_TRY_COMPILE(
    [
      namespace bar
      {
        template <class T> struct B 
	{ 
	  void baz(const T & = T());
	};
      }
      namespace foo 
      {
        using namespace bar;
        class A {};
        void f() { B<A> b; b.baz(); }
      }
    ],
    [ foo::f(); ],
    ac_cv_cxx_namespaces=yes,
    ac_cv_cxx_namespaces=no
  )]
)
if test "$ac_cv_cxx_namespaces" = yes ; then
  RINGING_USE_NAMESPACES=1;
else
  RINGING_USE_NAMESPACES=0;
fi
AC_SUBST(RINGING_USE_NAMESPACES)

dnl Check if platform supports template function specialisation
dnl
AC_CACHE_CHECK(
  [whether compiler supports template function specialisation],
  [ac_cv_cxx_template_function_specialisation],
  [AC_TRY_COMPILE(
    [
      template <class T> void foo(const T &) {}
      template <> void foo<int>(const int &) {}
    ],  
    [ foo((int)1); ],
    ac_cv_cxx_template_function_specialisation=yes,
    ac_cv_cxx_template_function_specialisation=no
  )]
)
if test "$ac_cv_cxx_template_function_specialisation" = yes ; then
  RINGING_USE_TEMPLATE_FUNCTION_SPECIALISATION=1
else
  RINGING_USE_TEMPLATE_FUNCTION_SPECIALISATION=0
fi
AC_SUBST(RINGING_USE_TEMPLATE_FUNCTION_SPECIALISATION)

dnl Check to see whether instantiating a class instantiates its 
dnl members' definitions or just declarations
dnl
AC_CACHE_CHECK(
  [whether class instantiation prematurely instantiates members],
  [ac_cv_cxx_premature_member_instantiation],
  [AC_TRY_COMPILE(
    [
      class A {};
      template <class T> struct foo { 
        bool bar() const { return a < b; }
        T a, b;
      };
    ],
    [ foo<A> f; return 0; ],
    ac_cv_cxx_premature_member_instantiation=no,
    ac_cv_cxx_premature_member_instantiation=yes
  )]
)
if test "$ac_cv_cxx_premature_member_instantiation" = yes ; then
  RINGING_PREMATURE_MEMBER_INSTANTIATION=1
else
  RINGING_PREMATURE_MEMBER_INSTANTIATION=0
fi
AC_SUBST(RINGING_PREMATURE_MEMBER_INSTANTIATION)

dnl Check to see whether the standard includes put their things in
dnl the std namespace
AC_CACHE_CHECK(whether standard includes use namespace std,
ac_cv_cxx_std,
[AC_TRY_COMPILE([#include] $iostream_name, [std::cout << 'x'; return 0;],
  ac_cv_cxx_std=yes, ac_cv_cxx_std=no)]
)
if test "$ac_cv_cxx_std" = yes; then
  RINGING_USE_STD=1;
else
  RINGING_USE_STD=0;
fi
AC_SUBST(RINGING_USE_STD)

dnl Now check whether the STL seems to work
AC_CACHE_CHECK(whether the Standard Template Library works,
ac_cv_cxx_stl,
[AC_TRY_COMPILE([#include] $list_name [
#if] $RINGING_USE_STD [
using namespace std;
#endif],[list<int> l; l.push_back(3);
list<int>::iterator i = l.begin(); ++i; return 0;],
  ac_cv_cxx_stl=yes, ac_cv_cxx_stl=no)]
)
if test "$ac_cv_cxx_stl" = no; then
  AC_MSG_WARN([You do not appear to have a working version of the Standard
Template Library (STL), which is necessary for compiling and using the
Ringing Class Library.]);
  can_build=no;
fi

if test "$can_build" = no; then
  AC_MSG_WARN([Some problems were encountered which mean that you will not
be able to build the Ringing Class Library.  You will still be able to install
and read the documentation.  If you edit the file ringing/common.h to reflect
what environment will be present when using the library, then you will also 
be able to install the header files.]);
fi

AC_OUTPUT(Makefile ringing/Makefile doc/Makefile examples/Makefile 
  ringing/common.h)
