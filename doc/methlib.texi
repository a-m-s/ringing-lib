\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename methlib.info
@settitle A Method Class Library
@iftex
@afourpaper
@end iftex
@c %**end of header

@ifinfo
This is the manual for the Method Class Library.

Copyright 1997 Martin Bright

Permission is granted to copy and distribute this manual, provided that
the copyright notice and this permission notice appear on all copies.
@end ifinfo

@titlepage
@title A Method Class Library
@author Martin Bright
@author mjb47@@cam.ac.uk

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1997 Martin Bright

Permission is granted to make and distribute copies of this manual,
provided that the copyright notice and this permission notice appear on
all copies.

This document was produced using Texinfo 2.145. On-line (info) and
plain text versions are also available.
@end titlepage
@ifinfo

@node Top, Introduction, (dir), (dir)
@top
@ifclear PLAINTEXT
The Method Class Library (methlib) is a library of C++ classes designed
for writing change ringing application programs.

This menu lists the available topics in the documentation. This
documentation is also available in text and PostScript versions.
@end ifclear
@ifset PLAINTEXT
This documentation is also available in on-line (info) and PostScript
versions.
@end ifset
@end ifinfo

@menu
* Introduction::                About the Method Class Library                
* The STL::                     A word about the Standard Template Library
* Rows and Changes::            Classes for manipulating rows and changes  
* Methods::                     
* Proof::                       Proving Methods and Touches True
* Musical Analysis::            Performing Musical Analysis of Touches
* Method classification::       
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Row and Change classes

* Row Operations::              Explanation of algebra on rows
* Row Properties::              Explanation of other properties of rows
* Changes::                     Explanation of how methlib deals with changes
* The row Class::               
* The change Class::            
* The rows and changes Classes::  
* The row_block class::         

The @code{row} class

* row Derivation::              
* row Constructors::            
* row Operators::               
* Other row Functions::         
* row static Functions::        

The @code{change} class

* change Derivation::           
* change Constructors::         
* change Operators::            
* Other change Functions::      

The @code{rows} and @code{changes} classes

* rows and changes Derivation::  
* rows and changes Constructors::  
* rows and changes Operators::  
* Other rows and changes Functions::  

The @code{row_block} class

* row_block Derivation::        
* row_block Constructors::      
* Other row_block Functions::   

The @code{proof} class

* proof Derivation::
* proof Constructors::
* proof Functions::
* proof Operators::             
* Falseness Storage::           
* How Proof Works::             

The @code{music} class

* music Derivation::            
* music Constructors::          
* music Functions::             
* music Operators::             

@end detailmenu
@end menu

@node Introduction, The STL, Top, Top
@chapter Introduction
@cindex introduction

The Method Class Library is a collection of C++ classes which implement
various concepts found in change ringing, and make it possible to
implement programs which use these concepts without having to write the
basic algorithms over and over again.

The library is split into several sections:
@itemize @bullet
@item
Classes for dealing with individual rows and changes, and how the
interact with each other

@item
Classes for building and manipulating methods

@item
Classes for accessing method libraries
@end itemize

Thus it is possible to use whatever part of the library is necessary for
your program; for example, a method editing program would use the method
classes, whereas a program to simulate call changes would just use the
row and change classes.

@node The STL, Rows and Changes, Introduction, Top
@chapter The Standard Template Library
@cindex Standard Template Library
@cindex STL

Before you can use the Method Class Library, you will need to have a
copy of the Standard Template Library (STL) which works with your
compiler. The STL is a set of templates which define containers such as
lists and sets, iterators to move through them, and various other useful
things.  If your compiler complains about not being able to find files
such as @file{vector.h} and @file{list.h} then this probably means that
you don't have the STL and need to get hold of it.

You can get the latest version of the STL, with documentation, by
anonymous FTP from @code{butler.hpl.hp.com} is the directory
@code{/stl}. An FAQ about the STL is also available here. If you are
using the GNU compiler (@code{g++}), a version of the STL is included in
the latest @code{libg++} library, available with the other GNU tools
from @code{prep.ai.mit.edu} in directory @code{/pub/gnu}.

@node Rows and Changes, Methods, The STL, Top
@chapter Row and Change classes
@cindex row
@cindex change

For ease of notation, I am using the idea that a @dfn{row} is an
individual permutation of bells (such as @samp{13572468}), and a
@dfn{change} is a means of getting from one row to another, by swapping
pairs of bells; the most convenient way to write a change is a place
notation (for example @samp{X} or @samp{1258}).

@menu
* Row Operations::              Explanation of algebra on rows
* Row Properties::              Explanation of other properties of rows
* Changes::                     Explanation of how methlib deals with changes
* The row Class::               
* The change Class::            
* The rows and changes Classes::  
* The row_block class::         
@end menu

@node Row Operations, Row Properties, Rows and Changes, Rows and Changes
@section Row operations
@cindex row algebra
@cindex algebra of rows
@cindex row operations
@cindex transposition

Rows have a set of operations which we can use on them; in mathematical
terms, they form a group. The most important operation is that of row
multiplication or transposition - in this operation, the bells in one
row are rearranged according to another row.

For example,
@example
21345678 * 13572468 = 23571468
@end example
@noindent and
@example
13572468 * 21345678 = 31572468
@end example

Note that the two above examples do @emph{not} give the same result;
that is, the order in which two things are multiplied does matter.

As an example of how row multiplication is used, suppose that we want to
know the 4th row of the lead of Plain Bob Major with lead head
@samp{17856342}. The 4th row of the first lead (which has a lead head of
rounds) is @samp{42618375}. Multiplying these together gives us the
answer we are looking for, namely @samp{57312846}.

The identity for this operation is rounds; in other words, any row
multiplied by rounds gives itself, and rounds multiplied by any row
gives that row.

It is possible to define the inverse of a row as the row which, when
multiplied by that row, will give rounds. For example, the inverse of
@samp{13572468} is @samp{15263748}, as 
@example
13572468 * 15263748 = 12345678
@end example

The opposite of row multiplication is row division. If @samp{a * b = c},
we can define @samp{c / b = a}. Using the same example as above, suppose
we have a lead of Plain Bob Major and we know that the fourth row is
@samp{57312846}, and we wish to find the lead head. Just divide by the
fourth row of the plain course (@samp{42618375}) to get the answer.

@node Row Properties, Changes, Row Operations, Rows and Changes
@section Row properties
@cindex row properties

There are several properties of rows which arise from group theory and
can be useful in looking at properties of methods.

@cindex order
The @dfn{order} of a row is the number of times which that row has to be
multiplied by itself before it gets back to rounds. For example, the row
@samp{21436587} has order 2, because if it is multiplied by itself
twice, you get back to rounds. Similarly the row @samp{23145678} has
order 3, and the row @samp{23456781} has order 8. This can be useful,
for example, in seeing how many leads of a method are needed in a plain
course before it comes round.

@cindex sign
@cindex parity
Another useful concept is the @dfn{sign} or @dfn{parity} of a row. A row
is considered @dfn{even} if it takes an even number of swaps of pairs of
bells to get from rounds to that row, and @dfn{odd} if it takes an odd
number of swaps. (It can be shown that whether the number is odd or even
doesn't depend on exactly what the sequence of swaps is).

@cindex cycles
Finally, every row can be expressed as a set of @dfn{cycles}. A cycle is
a set of bells which move round in a sequential way as the row is
repeated; for example, @samp{21345678} has only one cycle, which is
@samp{(12)}; and @samp{12356478} has one cycle, which is
@samp{(456)}. Combining these two cycles will give us the row @samp{213564678}.

@node Changes, The row Class, Row Properties, Rows and Changes
@section Changes
@cindex change

A @dfn{change} is a means for getting from one row to another. It works
by swapping over pairs of bells, and no bell may move more than one
place.

@cindex place notation
The normal way of representing a change is by place notation; a single
change is represented by a series of numbers which each correspond to a
place being made; for example, @samp{12} means that all bells swap,
apart from the 1 and the 2, which stay in the same place. If all the
bells swap, the place notation is @samp{X}.

@cindex swap
However, place notation is not the best way to store a change for the
purposes of calculation. Internally, the Method Class Library stores a
change as a series of swaps; each swap refers to a pair of bells which
are swapped over. This makes it particularly quick to apply a change to
a row; just go through the list of swaps, and swap each pair of bells
which appear.

@node The row Class, The change Class, Changes, Rows and Changes
@section The @code{row} class
@cindex @code{row} class

The @code{row} class stores a single row. It provides extensive
functions to manipulate rows and perform operations on them.

@menu
* row Derivation::              
* row Constructors::            
* row Operators::               
* Other row Functions::         
* row static Functions::        
@end menu

@node row Derivation, row Constructors, The row Class, The row Class
@subsection Derivation

This class is not derived from any other classes.

@example
class row;
@end example

@node row Constructors, row Operators, row Derivation, The row Class
@subsection Constructors

@deftypefn Constructor {} row::row (int @var{bells});
This constructs an empty row, where @var{bells} is the number of bells
which the row is to contain. Note that it is not initialised to
anything.
@end deftypefn

@deftypefn Constructor {} row::row (char *@var{s});
This constructs a row from a string, which should be the textual
representation of the row you wish to construct, for example
@samp{135246} or @samp{2143658709TE}.
@end deftypefn

@deftypefn Constructor {} row::row (const row& @var{r});
This is the copy constructor; it creates a copy of the given row.
@end deftypefn

@node row Operators, Other row Functions, row Constructors, The row Class
@subsection Operators

@deftypefn Operator row& row::operator= (const row& @var{r});
This copies one row to another.
@end deftypefn

@deftypefn Operator row& row::operator= (char *@var{s});
This sets the value of a row, given a string. The string @var{s} should
contain a textual representation of a row, such as @samp{21436587}. It
should also have the same number of bells as this row.
@end deftypefn

@deftypefn Operator int row::operator== (const row& @var{r}) const;
@deftypefnx Operator int row::operator!= (const row& @var{r}) const;
These compare two rows.
@end deftypefn

@deftypefn Operator int row::operator[] (int @var{i}) const;
This returns the @var{i}th bell in the row, with 0 being the treble,
and so on. Note that this is not an lvalue, so you cannot assign a value
to an individual bell in a row.
@end deftypefn

@deftypefn Operator row row::operator* (const row& @var{r}) const;
@deftypefnx Operator row& row::operator*= (const row& @var{r});
These functions multiply two rows together as explained above.
@end deftypefn

@deftypefn Operator row row::operator/ (const row& @var{r}) const;
@deftypefnx Operator row& row::operator/= (const row& @var{r});
These functions divide two rows, as explained above.
@end deftypefn

@deftypefn Operator row& operator*= (row& @var{r}, const change& @var{c});
@deftypefnx Operator row row::operator* (const change& @var{c}) const;
These functions apply a change to a row, by swapping over all the pairs
of bells which are specified in the change.
@end deftypefn

@deftypefn Operator ostream& operator<< (ostream& @var{o}, const row& @var{r});
This writes the row to the given output stream, in the same format as
returned by @code{row::print()}.
@end deftypefn

@node Other row Functions, row static Functions, row Operators, The row Class
@subsection Other functions

@deftypefun int row::bells (void) const;
This returns the number of bells which the row contains.
@end deftypefun

@c Silly bit to get round a bug
@ifinfo
@deftypefun row& row::rounds (void);
This sets the row to rounds.
@end deftypefun
@end ifinfo
@iftex
@deftypefun row@& row::rounds (void);
This sets the row to rounds.
@end deftypefun
@end iftex

@deftypefun int row::isrounds (void) const;
This returns 1 if the row is rounds, and 0 otherwise.
@end deftypefun

@deftypefun {char *} row::print (char *@var{s}) const;
This prints the row to the string @var{s}. Note that @var{s} must be
long enough.
@end deftypefun

@deftypefun row row::inverse (void) const;
This returns the inverse or a row, as explained above.
@end deftypefun

@deftypefun int row::sign (void) const;
This returns the sign or parity of a row; 1 for even, -1 for odd.
@end deftypefun

@deftypefun int row::order (void) const;
This returns the order of the row.
@end deftypefun

@deftypefun {char *} row::cycles (char *@var{result}) const;
This expresses the row as separate cycles. The string @var{result} will
afterwards contain a list of all the cycles in the row, separated by
commas; for example @code{row("21453678").cycles(s)} will return the
string @code{"12,345,6,7,8"}. Note that the string must be long enough.
@end deftypefun

@node row static Functions,  , Other row Functions, The row Class
@subsection @code{static} functions

@deftypefun {static char} row::b_to_c (char @var{b});
This returns the character representation of the given bell, specified
with 0 for the treble, and so on. Thus @code{row::b_to_c(2) == '3'} and
@code{row::b_to_c(10) = 'E'}.
@end deftypefun

@deftypefun {static int} row::c_to_b (char @var{c});
This returns the bell number which corresponds to the given character,
or -1 if the character doesn't represent a bell.
@end deftypefun

@deftypefun {static row} row::rounds (int @var{n});
This returns the row corresponding to rounds on @var{n} bells.
@end deftypefun

@node The change Class, The rows and changes Classes, The row Class, Rows and Changes
@section The @code{change} class
@cindex @code{change} class

The @code{change} class stores a single change, i.e. a means of getting
from one row to another.

@menu
* change Derivation::           
* change Constructors::         
* change Operators::            
* Other change Functions::      
@end menu

@node change Derivation, change Constructors, The change Class, The change Class
@subsection Derivation

This class is not derived from any other classes.

@example
class change;
@end example

@node change Constructors, change Operators, change Derivation, The change Class
@subsection Constructors

@deftypefn Constructor {} change::change (int @var{n});
This constructs an empty change for @var{n} bells, which will initially
contain no swaps, i.e. all bells will remain in the same place.
@end deftypefn

@deftypefn Constructor {} change::change (const change& @var{c});
This is the copy constructor; it makes a new copy of @var{c}.
@end deftypefn

@deftypefn Constructor {} change::change (int @var{n}, char *@var{pn});
This constructs a change on @var{n} bells, with place notation as given
in @var{pn}. This should consist of a sequence of numbers which signify
the places to be made, arranged in ascending order. If no places are to
be made, the string @code{"X"} should be used. Note that you
can miss out external places, unless no internal places are made at all.
@end deftypefn

@node change Operators, Other change Functions, change Constructors, The change Class
@subsection Operators

@deftypefn Operator change& change::operator= (const change& @var{c});
This assigns the value of one change to another.
@end deftypefn

@deftypefn Operator change& change::operator= (char *@var{pn});
This sets the change to the value indicated by the place notation in
string @var{pn}.
@end deftypefn

@deftypefn Operator int change::operator== (const change& @var{c}) const;
@deftypefnx Operator int change::operator!= (const change& @var{c}) const;
These compare two changes.
@end deftypefn

@deftypefn Operator int& operator*= (int& @var{i}, const change& @var{c});
@deftypefnx Operator int operator* (int @var{i}, const change& @var{c});
These return the effect of applying the change @var{c} to the bell
@var{i}. For example, @code{3 * "34" == 4}. This is useful in tracing
the path of one particular bell through a series of changes.
@end deftypefn

@deftypefn Operator ostream& operator<< (ostream& @var{o}, const change& @var{c});
This writes the place notation for the change @var{c} to the given
output stream.
@end deftypefn

@node Other change Functions,  , change Operators, The change Class
@subsection Other functions

@deftypefun int change::bells (void) const;
This returns the number of bells on which the change is defined.
@end deftypefun

@deftypefun int change::findswap (int @var{i}) const;
Returns 1 if the change swaps bells @var{i} and @var{i+1}, and 0
otherwise.
@end deftypefun

@deftypefun int change::findplace (int @var{i}) const;
Returns 1 if the change doesn't move the bell in the @var{i}th place
(i.e. if @var{i}ths place is made), and 0 otherwise.
@end deftypefun

@deftypefun int change::swap (int @var{i});
If the change doesn't currently swap bells @var{i} and @var{i+1}, then
this will add that swap. If those bells are swapped, this will remove
the swap. If the bells @var{i-1} and @var{i}, or @var{i+1} and
@var{i+2}, are currently swapped, those swaps are removed.

This function makes it possible for the user to edit changes in such a
way that they will always end up in a sensible state.
@end deftypefun

@deftypefun change change::reverse (void) const;
This returns the reverse of a change; that is, the change is flipped
over so that on 8 bells for example, 2nds place becomes 7ths place and
so on.
@end deftypefun

@deftypefun int change::internal (void) const;
This returns 1 if the change contains internal places, and 0 otherwise.
@end deftypefun

@node The rows and changes Classes, The row_block class, The change Class, Rows and Changes
@section The @code{rows} and @code{changes} classes
@cindex @code{rows} class, @code{changes} class

The @code{rows} and @code{changes} classes hold an array of rows or
changes, respectively.  For example, @code{changes} could hold a lead of
a method or a bob or single; @code{rows} could hold the rows for a particular
lead of a method, or course ends for a composition.

@menu
* rows and changes Derivation::  
* rows and changes Constructors::  
* rows and changes Operators::  
* Other rows and changes Functions::  
@end menu

@node rows and changes Derivation, rows and changes Constructors, The rows and changes Classes, The rows and changes Classes
@subsection Derivation

These classes are derived from @code{vector<row>} and @code{vector<change>}
classes respectively, but with the @code{protected} attribute.

@example
class rows : protected vector<row>;
class changes : protected vector<change>;
@end example

@node rows and changes Constructors, rows and changes Operators, rows and changes Derivation, The rows and changes Classes
@subsection Constructors

@deftypefn Constructor {} rows::rows (void);
@deftypefnx Constructor {} changes::changes (void);
These create empty arrays.
@end deftypefn

@deftypefn Constructor {} rows::rows (int @var{l}, int @var{b});
@deftypefnx Constructor {} changes::changes (int @var{l}, int @var{b});
These create an array of rows or changes containing @var{l} members,
each on @var{b} bells.
@end deftypefn

@deftypefn Constructor {} rows::rows (rows& @var{r});
@deftypefnx Constructor {} changes::changes (changes& @var{c});
Copy constructors.
@end deftypefn

@node rows and changes Operators, Other rows and changes Functions, rows and changes Constructors, The rows and changes Classes
@subsection Operators

@deftypefn Operator rows& rows::operator= (rows& @var{r});
@deftypefnx Operator changes& changes::operator= (changes& @var{c});
Copy assignment operators.
@end deftypefn

@deftypefn Operator row& rows::operator[] (int @var{i});
@deftypefnx Operator {const row&} rows::operator[] (int @var{i}) const;
@deftypefnx Operator changes& changes::operator[] (int @var{i});
@deftypefnx Operator {const changes&} changes::operator[] (int @var{i}) const;
These operators return the @var{i}th member of the array.
@end deftypefn

@node Other rows and changes Functions,  , rows and changes Operators, The rows and changes Classes
@subsection Other functions

@deftypefun int rows::length (void);
@deftypefunx int changes::length (void);
These return the number of elements in the array.
@end deftypefun

@deftypefun int rows::bells (void);
@deftypefunx int changes::bells (void);
These return the number of bells used by the rows or changes in the array.
@end deftypefun

@deftypefun row changes::asrow (void) const;
This returns a row which is the cumulative effect of all the changes in
the array, found by starting with rounds and applying all of the changes
to it one after the other.  For example, if the @code{changes} object
contains one lead of a method, then @code{asrow} will return the lead end
of the method.
@end deftypefun

@node The row_block class,  , The rows and changes Classes, Rows and Changes
@section The @code{row_block} class
@cindex @code{row_block} class

The @code{row_block} class is an array of rows which has associated with
it a pointer to an array of changes, and can recalculate itself from those
changes.  For example, suppose that the variable @code{c} of type
@code{changes} holds one lead of a method; then it is possible to define a
variable of type @code{row_class} which, once it is told what the lead head
is, will calculate the rows for one lead of the method.

@menu
* row_block Derivation::        
* row_block Constructors::      
* Other row_block Functions::   
@end menu

@node row_block Derivation, row_block Constructors, The row_block class, The row_block class
@subsection Derivation

The @code{row_block} class is derived from @code{rows}.

@example
class row_block : public rows;
@end example

@node row_block Constructors, Other row_block Functions, row_block Derivation, The row_block class
@subsection Constructors

@deftypefn Constructor {} row_block::row_block (changes& @var{c});
This creates a block of rows using the changes in @var{c}, starting
from rounds.
@end deftypefn

@deftypefn Constructor {} row_block::row_block (changes& @var{c}, row& @var{r});
This creates a block of rows using the changes in @var{c}, starting from
the row given in @var{r}.
@end deftypefn

@node  Other row_block Functions,  , row_block Constructors, The row_block class
@subsection Other functions

@ifinfo
@deftypefun row& row_block::set_start (row& @var{r});
This sets the first row to @var{r}.  Note that this function does @emph{not}
recalculate the rest of the rows afterwards; you must do this by calling
@code{recalculate()}.
@end deftypefun
@end ifinfo
@iftex
@deftypefun row@& row_block::set_start (row& @var{r});
This sets the first row to @var{r}.  Note that this function does @emph{not}
recalculate the rest of the rows afterwards; you must do this by calling
@code{recalculate()}.
@end deftypefun
@end iftex

@ifinfo
@deftypefun row_block& row_block::recalculate (int @var{start} = 0);
This recalculates all the rows in the array, starting from the element
numbered @var{start}; if this is not specified, all the rows are recalculated.
If, for example, you know that the @code{changes} object which the row block
is based on has been changes halfway through, you don't have to recalculate
all the rows, just the ones after that point.
@end deftypefun
@end ifinfo
@iftex
@deftypefun row_block@& row_block::recalculate (int @var{start} = 0);
This recalculates all the rows in the array, starting from the element
numbered @var{start}; if this is not specified, all the rows are recalculated.
If, for example, you know that the @code{changes} object which the row block
is based on has been changes halfway through, you don't have to recalculate
all the rows, just the ones after that point.
@end deftypefun
@end iftex

@ifinfo
@deftypefun changes& row_block::get_changes (void) const;
This returns the @code{changes} object on which the row block is based.
@end deftypefun
@end ifinfo
@iftex
@deftypefun changes@& row_block::get_changes (void) const;
This returns the @code{changes} object on which the row block is based.
@end deftypefun
@end iftex


@node Methods, Proof, Rows and Changes, Top
@chapter Method classes

The Method Class Library provides many useful functions for dealing with
methods, findinf information about them and classifying them.

A @dfn{method} is a set of changes.  Every method consists of one block
which is repeated over and over again; this is called a @dfn{lead}.  If,
at the end of one lead, every bell is in a different position, then the
method is called a @dfn{principle} and the leads are called @dfn{divisions}.
Any bells is a method which end up in the same place at the end of a lead
are called @dfn{hunt bells}.

The Method Class Library defines an object @code{method} which is simply
a block of changes (it is derived from @code{changes}) and which provides
a large range of member functions.  Many of these are used for finding
out things about the method, such as the number of leads in the plain course,
the type of method, the full name and so on. 

@node Proof, Musical Analysis, Methods, Top
@chapter Method and Touch Proving
@cindex proving rows
@cindex proof class

The proof class provides a simple way of checking that a block of rows are true. It provides functions for finding out where a particular block has failed. Additionally, it will can check blocks that are more than one extent long.

It is a template class, defined as @code{template <class RowIterator> class proof;}. You can therefore decide on your own block of rows format, as long as you can provide an iterator (see the STL) for it.

It will check ALL rows given, therefore if rounds are at the start and end, then one of them should be removed before passing to the object.

The proof class only stores the results, it does not make a copy of the actual rows. However, pointers to false rows will be stored, so don't destroy your rows before getting all the proof results. This may be changed in a later release.

@menu
* proof Derivation::            
* proof Constructors::          
* proof Functions::             
* proof Operators::             
* Falseness Storage::           
* How Proof Works::             
@end menu

@node proof Derivation, proof Constructors, Proof, Proof
@subsection Derivation

This class is not derived from any other classes.

@example
template <class RowIterator> class proof;
@end example

@node proof Constructors, proof Functions, proof Derivation, Proof
@subsection Constructors

@deftypefn Constructor {} proof::proof();
Default Constructor. Sets trueness to false. Use the prove function to provide the rows to prove.
@end deftypefn

@deftypefn Constructor {} proof::proof(RowIterator @var{first}, RowIterator @var{last});
This checks for repeated rows from first to last. Expects up to 1 extent only. Result is stored in class for later retrieval.
@end deftypefn

@deftypefn Constructor {} proof::proof(RowIterator @var{first}, RowIterator @var{last}, const int @var{max}, proof::hash_function @var{f});
This checks for repeated rows from first to last. Expects up to @var{max} extents. Result is stored in class for later retrieval.
@end deftypefn

@node proof Functions, proof Operators, proof Constructors, Proof
@subsection Functions

@deftypefn Function bool proof::proof(RowIterator @var{first}, RowIterator @var{last});
This checks for repeated rows from first to last. Expects up to 1 extent only. Full result is stored in class for later retrieval, but trueness of rows is returned.
@end deftypefn

@deftypefn Function bool proof::proof(RowIterator @var{first}, RowIterator @var{last}, const int @var{max}, proof::hash_function @var{f});
This checks for repeated rows from first to last. Expects up to @var{max} extents. Full result is stored in class for later retrieval, but trueness of rows is returned.
@end deftypefn

@ifinfo
@deftypefn Function const failinfo& proof::failed() const;
This function simply returns the data detailing where the touch has failed. (*note Falseness Storage::).
@end deftypefn
@end ifinfo
@iftex
@deftypefn Function const failinfo@& proof::failed() const;
This function simply returns the data detailing where the touch has failed.
@end deftypefn
@end iftex

@node proof Operators, Falseness Storage, proof Functions, Proof
@subsection Operators

@deftypefn Operator operator proof::int() const;
This returns true (or 1) if the touch is true.
@end deftypefn

@deftypefn Operator int proof::operator!() const;
This returns true (or 1) if the touch is not true.
@end deftypefn

@ifinfo
@deftypefn Operator friend ostream& operator<< <>(ostream& @var{o}, const proof<RowIterator>& @var{p});
Outputs to the ostream, @var{o}, if @var{p} is true or false in a predefined format. If p is false, then additional information regarding where is also output.
@end deftypefn
@end ifinfo
@iftex
@deftypefn Operator friend ostream@& operator<< <>(ostream@& @var{o}, const proof<RowIterator>@& @var{p});
Outputs to the ostream, @var{o}, if @var{p} is true or false in a predefined format. If p is false, then additional information regarding where is also output.
@end deftypefn
@end iftex

@node Falseness Storage, How Proof Works, proof Operators, Proof
@subsection How falseness is stored
@cindex falseness storage

When the proof class finds two or more rows that are the same, it stores the details in a private variable, @var{where}. This can be retrieved by the function @code{failed}. The variable is defined as:

@example
typedef list<linedetail> proof::failinfo;
failinfo @var{where};
@end example

linedetail is a struct defined as:

@example
struct linedetail @{
 row _row;
 list<int> _lines;
@};
@end example

When a row is repeated more than once, a new linedetail item is added to @var{where}. In the linedetail data is stored a pointer, @var{_row}, to the first of the matching rows, and the row numbers are put into @var{_lines}. If the first row given to the class matches the 11th row, then 0 and 10 will be placed into @var{_lines}. If there are three or more rows that all match, then the relevant numbers will be placed into the @var{_lines} list without repeating any.

@node How Proof Works,  , Falseness Storage, Proof
@subsection How it works
@cindex How proof works

There are two ways that the class can prove blocks of rows depending on if the number of rows is less or greater than an extent. In both methods, the procedures are carried through to the end to allow the user to see where the block of rows is false in all places, not just the first.

@subsection Single Extent

If the single extent version of the function @code{proof::prove} is called, then we follow this procedure.

Here we look at the first row and compare it to the rest. Then we proceed to the second and compare that to the rest (starting from the third, and going to the end). We then continue this until we have completed all the rows. If two rows match the details are stored and the trueness is set to false.

@subsection Multiple Extents

If the multiple extent version of the function @code{proof::prove} is called, then we follow this procedure.

Now we proceed through the list just once. Each row is put into a multimap, if at any time the amount of rows in this map exceed the maximum number of extents then the details are added into the failed information and the trueness is set to false.

@node Musical Analysis, Method classification, Proof, Top
@chapter Analysis of Music
@cindex Music Analysis
@cindex music class

The music class provides analysis for music within a set of rows. Like the proof class, it is also a template class defined as @code{template <class RowIterator> class music;}. Hence, you can define your own format for the set of rows as long as you can provide an iterator for it.

The music class processes each row just once, it does not store any rows. It assumes that the first row given is a handstroke row. The class should be able to handle any number of bells. If an odd number of bells is given, e.g. 5, then a tenor is assumed in looking for items like queens, e.g. 13524 essentially becomes 135246.

Each time the analysis function is called, the results stored in the class are reset to zero, and then incremented based on the rows given.

@menu
* music Derivation::            
* music Constructors::          
* music Functions::             
* music Operators::             
@end menu

@node music Derivation, music Constructors, Musical Analysis, Musical Analysis
@subsection Derivation

This class in not derived from any other classes.

@example
template <class RowIterator> class music;
@end example

@node music Constructors, music Functions, music Derivation, Musical Analysis
@subsection Constructors

@deftypefn Constructor {} music::music();
Default Constructor. Resets all the music variables to zero.
@end deftypefn

@deftypefn Constructor {} music::music(RowIterator @var{first}, RowIterator @var{last});
This constructor takes the rows and passes them to @code{music::change_rows} which resets the music variables and analyses all the rows. First and last should be an iterator to a container that stores rows. The first should also be a handstroke row.
@end deftypefn

@node music Functions, music Operators, music Constructors, Musical Analysis
@subsection Functions

@deftypefn Function inline void music::change_rows(RowIterator @var{first}, RowIterator @var{last});
This function resets all the music variables and the analyses the rows. First and last should be an iterator to a container that stores rows. The first should also be a handstroke row.
@end deftypefn

The following functions all return values depending on the last block of rows analysed.

@deftypefn Function bool music::queens(void) const;
This function returns true if queens was present.
@end deftypefn

@deftypefn Function bool music::titums(void) const;
This function returns true if titums was present.
@end deftypefn

@deftypefn Function bool music::kings(void) const;
This function returns true if kings was present.
@end deftypefn

@deftypefn Function bool music::reverse_rounds(void) const;
This function returns true if reverse_rounds was present.
@end deftypefn

@deftypefn Function int music::t_tminus1_at_back(void) const;
This function returns the number of 65s, 87s, 09s etc present at backstroke
@end deftypefn

@deftypefn Function int music::tminus2_t_at_the_back_hs(void) const;
This function returns the number of 46s, 68s, etc at the end of the change present at handstroke. Note, this also includes the number of 246s, 468s etc.
@end deftypefn

@deftypefn Function int music::tminus4_tminus2_t_at_the_back_hs(void) const;
This function returns the number of 246s, 468s, etc at the end of the change present at handstroke.
@end deftypefn

@deftypefn Function int music::tminus2_t_at_the_back_bs(void) const;
This function returns the number of 46s, 68s, etc at the end of the change present at backstroke. Note, this also includes the number of 246s, 468s etc.
@end deftypefn

@deftypefn Function int music::tminus4_tminus2_t_at_the_back_bs(void) const;
This function returns the number of 246s, 468s, etc at the end of the change present at backstroke.
@end deftypefn

@deftypefn Function int music::rollup_3(void) const;
This function returns the number of three bell rollups present on the back, this does not include other numbers of rollups.
@end deftypefn

@deftypefn Function int music::rollup_4(void) const;
This function returns the number of four bell rollups present on the back, this does not include other numbers of rollups.
@end deftypefn

@deftypefn Function int music::reverse_rollup_3(void) const;
This functoin returns the number of reverse three bell rollups present on the front (e.g. 876, 654), this does not include other number of rollups.
@end deftypefn

@deftypefn Function int music::reverse_rollup_4(void) const;
This functoin returns the number of reverse four bell rollups present on the front (e.g. 8765, 6543), this does not include other number of rollups.
@end deftypefn

@node music Operators,  , music Functions, Musical Analysis
@subsection Operators

@ifinfo
@deftypefn Operator friend ostream& operator<< <>(ostream& @var{o}, const music<RowIterator>& @var{m});
Outputs to the ostream a string containing the following details:

@example
qktr,1,2,3,4,5,6,7,8,9
@end example

Letter are displayed only when the following music in the touch, otherwise there is just a space:
@example
q = queens
k = kings
t = titums
r = reverse rounds
@end example

Otherwise numbers provide the following information
@example
1 = Number of 3 bell rollups in the touch (i.e.  678 on the back)
2 = Number of 4 bell rollups in the touch (i.e. 5678 on the back)
3 = Number of reverse 3 bell rollups off the front (i.e. 654 or 876)
4 = Number of reverse 4 bell rollups off the front (i.e. 6543 or 8765)
5 = Number of 46s or 68s etc at handstroke (note: this also adds in total for item 7).
6 = Number of 46s or 68s etc at backstroke (note: this also adds in total for item 8).
7 = Number of 246s or 468s etc at handstroke
8 = Number of 246s or 468s etc at backstroke
9 = Number of 65s or 87s at backstroke (will be zero for odd nos of bells)
@end example
@end deftypefn
@end ifinfo
@iftex
@deftypefn Operator friend ostream@& operator<< <>(ostream@& @var{o}, const music<RowIterator>@& @var{m});
Outputs to the ostream a string containing the following details:

@example
qktr,1,2,3,4,5,6,7,8,9
@end example

Letter are displayed only when the following music in the touch, otherwise there is just a space:
@example
q = queens
k = kings
t = titums
r = reverse rounds
@end example

Otherwise numbers provide the following information
@example
1 = Number of 3 bell rollups in the touch (i.e.  678 on the back)
2 = Number of 4 bell rollups in the touch (i.e. 5678 on the back)
3 = Number of reverse 3 bell rollups off the front (i.e. 654 or 876)
4 = Number of reverse 4 bell rollups off the front (i.e. 6543 or 8765)
5 = Number of 46s or 68s etc at handstroke (note: this also adds in total for item 7).
6 = Number of 46s or 68s etc at backstroke (note: this also adds in total for item 8).
7 = Number of 246s or 468s etc at handstroke
8 = Number of 246s or 468s etc at backstroke
9 = Number of 65s or 87s at backstroke (will be zero for odd nos of bells)
@end example
@end deftypefn
@end iftex

@node Method classification, Index, Musical Analysis, Top
@chapter Classification of methods

Methods are classified according to section E, subsections B and C, of
the Central Council's Decisions.

@node Index,  , Method classification, Top
@unnumbered Index

@printindex cp

@contents
@bye
